<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <meta name="theme-color" content="#0b0c10" />
  <meta name="color-scheme" content="dark" />
  <link rel="manifest" href="./manifest.webmanifest" />
  <link rel="icon" href="./icon.svg" type="image/svg+xml" />
  <link rel="apple-touch-icon" href="./icon.svg" />
  <title>VocabForge</title>

  <style>
    :root{
      --bg:#0b0c10;
      --panel:#11131a;
      --panel2:#0f1117;
      --text:#e7eaf0;
      --muted:#a7afc0;
      --faint:#7f8798;
      --line:#222636;
      --accent:#7aa2ff;
      --good:#3ddc97;
      --meh:#ffcc66;
      --bad:#ff5c7a;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius2: 22px;
      --tap: 52px;
      --font: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      background:linear-gradient(180deg, #07080b 0%, var(--bg) 35%, #07080b 100%);
      color:var(--text);
      font-family:var(--font);
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }
    header{
      position:sticky; top:0; z-index:10;
      background:rgba(11,12,16,.86);
      backdrop-filter: blur(12px);
      border-bottom:1px solid rgba(34,38,54,.7);
      padding:16px 16px 12px 16px;
    }
    .toprow{display:flex;align-items:center;justify-content:space-between;gap:12px;max-width:980px;margin:0 auto;}
    .brand{display:flex;flex-direction:column;gap:2px;}
    .brand .title{font-size:18px;font-weight:800;letter-spacing:.2px;}
    .brand .sub{font-size:12px;color:var(--muted);}
    main{padding:14px 16px 96px 16px;}
    .wrap{max-width:980px;margin:0 auto}

    .grid{display:grid;grid-template-columns:1fr;gap:12px;}
    @media (min-width: 860px){.grid{grid-template-columns:1.2fr .8fr;}}

    .card{
      background:linear-gradient(180deg, rgba(17,19,26,.92) 0%, rgba(15,17,23,.92) 100%);
      border:1px solid rgba(34,38,54,.85);
      border-radius:var(--radius2);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .card .hd{padding:14px 14px 10px 14px;border-bottom:1px solid rgba(34,38,54,.75);display:flex;align-items:center;justify-content:space-between;gap:10px;}
    .card .hd h2{margin:0;font-size:14px;letter-spacing:.2px;color:var(--muted);font-weight:650;text-transform:uppercase;}
    .card .bd{padding:14px}

    .kpiRow{display:grid;grid-template-columns:repeat(3,minmax(0,1fr));gap:10px;}
    .kpi{background:rgba(11,12,16,.6);border:1px solid rgba(34,38,54,.8);border-radius:14px;padding:12px;min-height:74px;}
    .kpi .n{font-size:22px;font-weight:900}
    .kpi .l{font-size:12px;color:var(--muted);margin-top:4px}

    .btnRow{display:flex;gap:10px;flex-wrap:wrap}
    button, .btn{
      appearance:none;border:none;
      background:rgba(122,162,255,.16);
      color:var(--text);
      border:1px solid rgba(122,162,255,.35);
      padding:12px 14px;
      border-radius:16px;
      font-weight:750;
      min-height:var(--tap);
      cursor:pointer;
      text-decoration:none;
      display:inline-flex;align-items:center;justify-content:center;gap:10px;
      user-select:none;
    }
    button:active{transform: translateY(1px)}
    .btn.secondary{background:rgba(17,19,26,.75);border-color:rgba(34,38,54,.9);}
    .btn.good{background:rgba(61,220,151,.16);border-color:rgba(61,220,151,.35)}
    .btn.meh{background:rgba(255,204,102,.14);border-color:rgba(255,204,102,.35)}
    .btn.bad{background:rgba(255,92,122,.14);border-color:rgba(255,92,122,.35)}
    .btn.full{width:100%}
    .btn.small{min-height:44px;padding:10px 12px;border-radius:14px;font-weight:650;font-size:13px}

    .field{display:flex;flex-direction:column;gap:8px;margin-bottom:12px}
    label{font-size:12px;color:var(--muted);letter-spacing:.2px}
    input[type="text"], input[type="url"], input[type="password"], textarea, select{
      width:100%;
      background:rgba(11,12,16,.65);
      border:1px solid rgba(34,38,54,.9);
      color:var(--text);
      border-radius:16px;
      padding:12px 12px;
      font-size:16px;
      outline:none;
    }
    textarea{min-height:120px; resize:vertical; line-height:1.35}

    .hint{font-size:12px;color:var(--faint);line-height:1.3}
    .hr{height:1px;background:rgba(34,38,54,.85);margin:12px 0}

    .list{display:flex;flex-direction:column;gap:8px;}
    .item{display:flex;align-items:center;justify-content:space-between;gap:10px;padding:12px 12px;background:rgba(11,12,16,.55);border:1px solid rgba(34,38,54,.85);border-radius:16px;cursor:pointer;min-height:var(--tap);}
    .item:active{transform: translateY(1px)}
    .w{font-size:16px;font-weight:900;letter-spacing:.2px}
    .meta{font-size:12px;color:var(--muted);margin-top:3px;white-space:pre-wrap}

    .badge{font-size:12px;padding:6px 10px;border-radius:999px;border:1px solid rgba(34,38,54,.9);background:rgba(17,19,26,.65);color:var(--muted);white-space:nowrap;}

    .tabs{
      position:fixed;left:0;right:0;bottom:0;z-index:10;
      padding:10px 12px calc(10px + env(safe-area-inset-bottom)) 12px;
      background:rgba(11,12,16,.86);
      backdrop-filter: blur(12px);
      border-top:1px solid rgba(34,38,54,.7);
    }
    .tabs .inner{max-width:980px;margin:0 auto;display:grid;grid-template-columns:repeat(3,1fr);gap:10px;}
    .tab{min-height:50px;border-radius:16px;background:rgba(17,19,26,.65);border:1px solid rgba(34,38,54,.85);color:var(--muted);font-weight:800;font-size:13px;}
    .tab.active{background:rgba(122,162,255,.14);border-color:rgba(122,162,255,.35);color:rgba(225,235,255,.98)}

    .reviewShell{min-height: calc(100vh - 140px); display:flex; flex-direction:column; gap:12px;}
    .reviewCard{flex:1;border-radius:24px;}
    .bigWord{font-size:34px;font-weight:950;letter-spacing:.3px;margin:0 0 10px 0;}
    .blockTitle{font-size:12px;text-transform:uppercase;letter-spacing:.2px;color:var(--muted);margin:14px 0 6px 0;font-weight:800;}
    .para{white-space:pre-wrap;line-height:1.42;color:rgba(231,234,240,.95);font-size:16px;}

    .toast{
      position:fixed;left:50%;bottom:80px;transform:translateX(-50%);
      background:rgba(17,19,26,.92);
      border:1px solid rgba(34,38,54,.9);
      border-radius:999px;
      padding:10px 14px;
      color:var(--text);
      box-shadow: var(--shadow);
      opacity:0;pointer-events:none;
      transition:opacity .18s ease, transform .18s ease;
      max-width:min(92vw,760px);
      white-space:nowrap;overflow:hidden;text-overflow:ellipsis;
      font-weight:800;z-index:50;
    }
    .toast.on{opacity:1;transform:translateX(-50%) translateY(-4px);}

    .viewer{
      width:100%;
      height:70vh;
      border:1px solid rgba(34,38,54,.85);
      border-radius:16px;
      background:rgba(11,12,16,.55);
      overflow:hidden;
    }
    .viewer iframe{width:100%;height:100%;border:0;}

    .readingSheet{
      background:linear-gradient(180deg, rgba(17,19,26,.96) 0%, rgba(15,17,23,.96) 100%);
      border:1px solid rgba(34,38,54,.85);
      border-radius:var(--radius2);
      box-shadow: var(--shadow);
      overflow:hidden;
      display:flex;
      flex-direction:column;
      max-height: calc(100vh - 160px);
    }
    .sheetToolbar{
      display:flex;
      align-items:center;
      gap:12px;
      flex-wrap:wrap;
      padding:12px 14px;
      border-bottom:1px solid rgba(34,38,54,.75);
      background:rgba(11,12,16,.4);
    }
    .sheetToolbar h2{ margin:0; font-size:14px; letter-spacing:.2px; color:var(--muted); font-weight:650; text-transform:uppercase; }
    .sheetToolbar .spacer{ flex:1; min-width:8px; }
    .sheetToolbar select{ padding:8px 10px; min-height:40px; border-radius:12px; font-size:13px; }
    .sheetScroll{
      overflow:auto;
      flex:1;
      min-height:0;
    }
    .sheetTable{
      width:100%;
      border-collapse:collapse;
      font-size:14px;
    }
    .sheetTable th{
      position:sticky;
      top:0;
      z-index:2;
      background:rgba(17,19,26,.98);
      border-bottom:2px solid rgba(34,38,54,.9);
      padding:10px 12px;
      text-align:left;
      font-size:11px;
      font-weight:800;
      text-transform:uppercase;
      letter-spacing:.25px;
      color:var(--muted);
    }
    .sheetTable td{
      border-bottom:1px solid rgba(34,38,54,.6);
      padding:10px 12px;
      vertical-align:top;
    }
    .sheetTable tbody tr{
      transition:background .12s ease;
    }
    .sheetTable tbody tr:hover{
      background:rgba(122,162,255,.06);
    }
    .sheetTable tbody tr.sheetNewRow{ background:rgba(122,162,255,.08); }
    .sheetTable tbody tr.sheetNewRow:hover{ background:rgba(122,162,255,.1); }
    .sheetTable .colAuthor{ width:14%; min-width:90px; }
    .sheetTable .colTitle{ width:22%; min-width:140px; font-weight:700; color:var(--text); }
    .sheetTable .colDesc{ width:auto; max-width:40%; color:var(--muted); font-size:13px; line-height:1.35; }
    .sheetTable .colStatus{ width:10%; min-width:72px; }
    .sheetTable .colActions{ width:80px; text-align:right; }
    .sheetTable input.cellInput, .sheetTable textarea.cellInput{
      width:100%;
      min-width:0;
      padding:8px 10px;
      font-size:14px;
      border-radius:10px;
      border:1px solid rgba(34,38,54,.8);
      background:rgba(11,12,16,.7);
      color:var(--text);
      outline:none;
    }
    .sheetTable input.cellInput:focus, .sheetTable textarea.cellInput:focus{
      border-color:var(--accent);
      box-shadow:0 0 0 2px rgba(122,162,255,.2);
    }
    .sheetTable textarea.cellInput{ min-height:36px; resize:vertical; line-height:1.3; }
    .sheetTable .cellDesc{ white-space:pre-wrap; word-break:break-word; max-height:3.6em; overflow:hidden; text-overflow:ellipsis; display:-webkit-box; -webkit-line-clamp:2; line-clamp:2; -webkit-box-orient:vertical; }
    .sheetTable .statusDot{ display:inline-block; width:8px; height:8px; border-radius:50%; margin-right:6px; }
    .sheetTable .statusDot.TO_READ{ background:var(--faint); }
    .sheetTable .statusDot.READING{ background:var(--accent); }
    .sheetTable .statusDot.DONE{ background:var(--good); }
    .sheetTable .actBtn{ padding:6px 10px; margin-left:4px; border-radius:10px; font-size:12px; font-weight:700; cursor:pointer; border:none; background:rgba(34,38,54,.8); color:var(--muted); }
    .sheetTable .actBtn:hover{ background:rgba(122,162,255,.25); color:var(--text); }
    .sheetTable .actBtn.del:hover{ background:rgba(255,92,122,.2); color:var(--bad); }

    .readingFeedback{
      border-top:1px solid rgba(34,38,54,.75);
      padding:12px 14px;
      background:rgba(11,12,16,.4);
    }
    .readingFeedback summary{ cursor:pointer; font-size:12px; font-weight:700; color:var(--muted); letter-spacing:.2px; user-select:none; }
    .readingFeedback summary:hover{ color:var(--text); }
    .readingFeedback .feedbackBody{ margin-top:10px; }
    .readingFeedback textarea{ min-height:70px; margin-bottom:8px; }
  </style>
</head>
<body>
<header>
  <div class="toprow">
    <div class="brand">
      <div class="title">VocabForge</div>
      <div class="sub">Vocabulary + reading list · offline-first (sync when online)</div>
    </div>
    <div class="brand" style="align-items:flex-end">
      <div class="sub" id="swText">Offline cache: …</div>
      <div class="sub" id="syncText">Sync: …</div>
    </div>
  </div>
</header>

<main>
  <div class="wrap" id="viewRoot"></div>
</main>

<nav class="tabs">
  <div class="inner">
    <button class="tab" data-nav="home">Home</button>
    <button class="tab" data-nav="review">Review</button>
    <button class="tab" data-nav="reading">Reading</button>
  </div>
</nav>

<div class="toast" id="toast"></div>

<script>
(() => {
  // Storage keys
  const LS_CARDS = "vocabforge.cards.v3";
  const LS_READING = "vocabforge.reading.v2";
  const LS_READING_FEEDBACK = "vocabforge.reading.feedback.v1";
  const LS_META = "vocabforge.meta.v2";

  // OpenAI
  const LS_OPENAI_KEY = "vocabforge.openaiKey.v1";
  const OPENAI_MODEL = "gpt-4o-mini";

  // GitHub Gist Sync
  const LS_GH_TOKEN = "vocabforge.ghToken.v1";
  const LS_GIST_ID = "vocabforge.gistId.v1";
  const DEFAULT_GIST_ID = "5af41e31e118e48021be2da7e46c1d9f";

  const BOX_INTERVAL_DAYS = { 1: 1, 2: 3, 3: 7 };

  // IndexedDB for PDFs (device-local only)
  const DB_NAME = "vocabforge";
  const DB_VER = 1;
  const STORE_PDFS = "pdfs";

  const $ = (sel, el=document) => el.querySelector(sel);
  const $$ = (sel, el=document) => Array.from(el.querySelectorAll(sel));
  const now = () => Date.now();

  function toast(msg) {
    const el = $("#toast");
    el.textContent = msg;
    el.classList.add("on");
    setTimeout(() => el.classList.remove("on"), 1400);
  }

  function safeJsonParse(text) {
    try { return JSON.parse(text); } catch { return null; }
  }

  function uid() {
    return "id_" + Math.random().toString(16).slice(2) + "_" + Date.now().toString(16);
  }

  function startOfTodayLocalTs() {
    const d = new Date();
    d.setHours(0,0,0,0);
    return d.getTime();
  }
  function daysToMs(days){ return days * 24 * 60 * 60 * 1000; }
  function clamp(n, min, max){ return Math.max(min, Math.min(max, n)); }

  // ----- OpenAI -----
  function getOpenAIKey(){
    return (localStorage.getItem(LS_OPENAI_KEY) || "").trim();
  }
  function setOpenAIKey(key){
    const k = (key || "").trim();
    if (!k) localStorage.removeItem(LS_OPENAI_KEY);
    else localStorage.setItem(LS_OPENAI_KEY, k);
  }

  async function openaiResponses({ input }){
    const key = getOpenAIKey();
    if (!key) throw new Error("NO_KEY");

    const res = await fetch("https://api.openai.com/v1/responses", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${key}`
      },
      body: JSON.stringify({
        model: OPENAI_MODEL,
        input,
        text: { format: { type: "json_object" } }
      })
    });

    if (!res.ok) {
      const t = await res.text().catch(() => "");
      throw new Error(`OPENAI_${res.status}:${t.slice(0,200)}`);
    }

    return await res.json();
  }

  function extractTextFromResponses(json){
    try {
      const out = json?.output;
      if (!Array.isArray(out)) return "";
      let text = "";
      for (const item of out) {
        const content = item?.content;
        if (!Array.isArray(content)) continue;
        for (const c of content) if (c?.type === "output_text") text += (c.text || "");
      }
      return (text || "").trim();
    } catch { return ""; }
  }

  async function generateCardFields(word){
    const prompt = `You are VocabDeck. Write like a funny friend in a group chat — confident, punchy, a little roast-y, not academic.\n\nWORD: ${word}\n\nReturn STRICT JSON with keys: definition (string), examples (string with 4-6 lines), replaces (string).\n\nSTYLE RULES:\n- BRO TERM energy. Gym convos, sports takes, bar arguments, half-serious politics, dating stories.\n- Examples should feel like responses you'd actually send.\n- Mix ironic casual usage + at most 1 serious usage if needed.\n`;

    const json = await openaiResponses({ input: [{ role: "user", content: prompt }] });
    const text = extractTextFromResponses(json);
    const parsed = safeJsonParse(text);
    if (!parsed) throw new Error("BAD_JSON");
    return {
      definition: String(parsed.definition || "").trim(),
      examples: String(parsed.examples || "").trim(),
      replaces: String(parsed.replaces || "").trim()
    };
  }

  async function gradeSentenceAI({ word, definition, examples, sentence }){
    const prompt = `You are a strict but helpful usage coach. Grade whether the sentence uses the target word correctly and naturally.\n\nWORD: ${word}\n\nMeaning context: ${definition || "(none)"}\n\nExamples context:\n${examples || "(none)"}\n\nUSER SENTENCE:\n${sentence}\n\nReturn STRICT JSON with keys: grade (number 0-10), feedback (string 1-3 sentences), corrected (string optional).\n`;

    const json = await openaiResponses({ input: [{ role: "user", content: prompt }] });
    const text = extractTextFromResponses(json);
    const parsed = safeJsonParse(text);
    if (!parsed) throw new Error("BAD_JSON");
    return {
      grade: Number(parsed.grade),
      feedback: String(parsed.feedback || "").trim(),
      corrected: String(parsed.corrected || "").trim()
    };
  }

  // ----- Sync (GitHub Gist) -----
  function getGistId(){
    return (localStorage.getItem(LS_GIST_ID) || DEFAULT_GIST_ID).trim();
  }
  function setGistId(id){
    const v = (id || "").trim();
    if (!v) localStorage.removeItem(LS_GIST_ID);
    else localStorage.setItem(LS_GIST_ID, v);
  }
  function getGhToken(){
    return (localStorage.getItem(LS_GH_TOKEN) || "").trim();
  }
  function setGhToken(t){
    const v = (t || "").trim();
    if (!v) localStorage.removeItem(LS_GH_TOKEN);
    else localStorage.setItem(LS_GH_TOKEN, v);
  }

  function syncSetStatus(text){
    const el = $("#syncText");
    if (el) el.textContent = `Sync: ${text}`;
  }

  async function gistFetchData(){
    const token = getGhToken();
    const gistId = getGistId();
    if (!token) throw new Error("NO_GH_TOKEN");
    if (!gistId) throw new Error("NO_GIST_ID");

    const res = await fetch(`https://api.github.com/gists/${gistId}`, {
      headers: {
        "Accept": "application/vnd.github+json",
        "Authorization": `token ${token}`
      }
    });
    if (!res.ok) {
      const t = await res.text().catch(() => "");
      throw new Error(`GIST_GET_${res.status}:${t.slice(0,200)}`);
    }
    const json = await res.json();
    const file = json?.files?.["vocabforge-data.json"];
    const content = file?.content;
    const parsed = safeJsonParse(content || "");
    if (!parsed) {
      return { version: 1, updatedAt: 0, cards: [], reading: [] };
    }
    return {
      version: parsed.version || 1,
      updatedAt: Number(parsed.updatedAt || 0),
      cards: Array.isArray(parsed.cards) ? parsed.cards : [],
      reading: Array.isArray(parsed.reading) ? parsed.reading : []
    };
  }

  async function gistPutData(payload){
    const token = getGhToken();
    const gistId = getGistId();
    if (!token) throw new Error("NO_GH_TOKEN");
    if (!gistId) throw new Error("NO_GIST_ID");

    const res = await fetch(`https://api.github.com/gists/${gistId}`, {
      method: "PATCH",
      headers: {
        "Accept": "application/vnd.github+json",
        "Content-Type": "application/json",
        "Authorization": `token ${token}`
      },
      body: JSON.stringify({
        files: {
          "vocabforge-data.json": {
            content: JSON.stringify(payload, null, 0)
          }
        }
      })
    });
    if (!res.ok) {
      const t = await res.text().catch(() => "");
      throw new Error(`GIST_PATCH_${res.status}:${t.slice(0,200)}`);
    }
    return true;
  }

  function ensureUpdatedAt(item){
    if (!item || typeof item !== "object") return item;
    if (!Number.isFinite(item.updatedAt)) item.updatedAt = item.dateAdded || now();
    return item;
  }

  function mergeById(localArr, remoteArr){
    const out = new Map();
    for (const a of (remoteArr || [])) {
      if (!a || !a.id) continue;
      out.set(a.id, ensureUpdatedAt(structuredClone(a)));
    }
    for (const a of (localArr || [])) {
      if (!a || !a.id) continue;
      const existing = out.get(a.id);
      const cand = ensureUpdatedAt(structuredClone(a));
      if (!existing || (cand.updatedAt || 0) >= (existing.updatedAt || 0)) out.set(a.id, cand);
    }
    return Array.from(out.values());
  }

  function getLocalPayload(){
    return {
      version: 1,
      updatedAt: getLocalUpdatedAt(),
      cards: loadCards(),
      reading: loadReading()
    };
  }

  function getLocalUpdatedAt(){
    const meta = safeJsonParse(localStorage.getItem(LS_META) || "{}") || {};
    return Number(meta.updatedAt || 0);
  }

  function bumpLocalUpdatedAt(){
    const meta = safeJsonParse(localStorage.getItem(LS_META) || "{}") || {};
    meta.updatedAt = now();
    localStorage.setItem(LS_META, JSON.stringify(meta));
  }

  async function syncOnce(){
    if (!navigator.onLine) {
      syncSetStatus("offline");
      return;
    }
    if (!getGhToken()) {
      syncSetStatus("no token");
      return;
    }

    try {
      syncSetStatus("syncing…");

      const remote = await gistFetchData();
      const local = getLocalPayload();

      // Merge by item.updatedAt to avoid clobber
      const mergedCards = mergeById(local.cards, remote.cards);
      const mergedReading = mergeById(local.reading, remote.reading);

      // Compute merged updatedAt
      const mergedUpdatedAt = Math.max(
        Number(remote.updatedAt || 0),
        Number(local.updatedAt || 0),
        ...mergedCards.map(x => Number(x.updatedAt || 0)),
        ...mergedReading.map(x => Number(x.updatedAt || 0))
      );

      // Write merged to local
      saveCards(mergedCards, { silentBump: true });
      saveReading(mergedReading, { silentBump: true });
      setLocalUpdatedAt(mergedUpdatedAt);

      // Push merged back to remote (keeps both devices converged)
      await gistPutData({ version: 1, updatedAt: mergedUpdatedAt, cards: mergedCards, reading: mergedReading });

      syncSetStatus("ok");
    } catch (e) {
      console.warn(e);
      syncSetStatus("error");
    }
  }

  function setLocalUpdatedAt(ts){
    const meta = safeJsonParse(localStorage.getItem(LS_META) || "{}") || {};
    meta.updatedAt = Number(ts || 0);
    localStorage.setItem(LS_META, JSON.stringify(meta));
  }

  // ----- Data models -----
  function normalizeSentenceHistory(arr){
    if (!Array.isArray(arr)) return [];
    return arr.map(x => {
      if (typeof x === "string") return { t: x, at: null, grade: null, feedback: "" };
      if (x && typeof x === "object") {
        return {
          t: String(x.t ?? x.text ?? "").trim(),
          at: Number.isFinite(x.at) ? x.at : null,
          grade: (x.grade === null || x.grade === undefined) ? null : Number(x.grade),
          feedback: (x.feedback ?? x.fb ?? "") ? String(x.feedback ?? x.fb) : ""
        };
      }
      return { t: "", at: null, grade: null, feedback: "" };
    }).filter(e => e.t);
  }

  function loadCards(){
    const raw = localStorage.getItem(LS_CARDS);
    if (!raw) return [];
    const parsed = safeJsonParse(raw);
    if (!Array.isArray(parsed)) return [];
    return parsed.map(c => {
      const card = {
        id: c.id || uid(),
        word: c.word || "",
        definition: c.definition ?? "",
        examples: c.examples ?? "",
        replaces: c.replaces ?? "",
        mySentence: c.mySentence ?? "",
        mySentenceHistory: normalizeSentenceHistory(c.mySentenceHistory),
        timesReviewed: Number.isFinite(c.timesReviewed) ? c.timesReviewed : 0,
        nailedCount: Number.isFinite(c.nailedCount) ? c.nailedCount : 0,
        box: clamp((c.box ?? 1), 1, 3),
        lastReviewedTs: Number.isFinite(c.lastReviewedTs) ? c.lastReviewedTs : null,
        dateAdded: Number.isFinite(c.dateAdded) ? c.dateAdded : now(),
        updatedAt: Number.isFinite(c.updatedAt) ? c.updatedAt : (c.dateAdded || now())
      };
      return card;
    });
  }

  function saveCards(cards, opts={}){
    localStorage.setItem(LS_CARDS, JSON.stringify(cards));
    if (!opts.silentBump) bumpLocalUpdatedAt();
  }

  function computeStatus(card){
    if ((card.nailedCount || 0) >= 5) return "FUNCTIONAL";
    if ((card.timesReviewed || 0) > 0) return "LEARNING";
    return "NEW";
  }
  function isDue(card, todayTs = startOfTodayLocalTs()){
    const intervalMs = daysToMs(BOX_INTERVAL_DAYS[clamp(card.box || 1, 1, 3)]);
    if (!card.lastReviewedTs) return true;
    const last = new Date(card.lastReviewedTs);
    last.setHours(0,0,0,0);
    return (last.getTime() + intervalMs) <= todayTs;
  }

  function normalizeWord(w){ return (w || "").trim().replace(/\s+/g, " "); }
  function uniqueWords(words){
    const seen = new Set();
    const out = [];
    for (const w of words) {
      const n = normalizeWord(w);
      if (!n) continue;
      const k = n.toLowerCase();
      if (seen.has(k)) continue;
      seen.add(k);
      out.push(n);
    }
    return out;
  }

  function loadReading(){
    const raw = localStorage.getItem(LS_READING);
    if (!raw) return [];
    const parsed = safeJsonParse(raw);
    if (!Array.isArray(parsed)) return [];
    return parsed.map(x => ({
      id: x.id || uid(),
      type: x.type || "article",
      title: x.title || "",
      author: x.author || "",
      url: x.url || "",
      status: x.status || "TO_READ",
      notes: x.notes || "",
      pdfId: x.pdfId || null,
      // Tombstone delete so sync can propagate deletes across devices
      deletedAt: Number.isFinite(x.deletedAt) ? x.deletedAt : null,
      dateAdded: Number.isFinite(x.dateAdded) ? x.dateAdded : now(),
      updatedAt: Number.isFinite(x.updatedAt) ? x.updatedAt : (x.dateAdded || now())
    }));
  }

  function isDeleted(item){
    return !!(item && Number.isFinite(item.deletedAt) && item.deletedAt > 0);
  }

  function readingSoftDelete(id){
    const all = loadReading();
    const t = now();
    for (const it of all) {
      if (it.id === id) {
        it.deletedAt = t;
        it.updatedAt = t;
      }
    }
    return all;
  }

  function readingSoftDeleteAll(){
    const all = loadReading();
    const t = now();
    for (const it of all) {
      it.deletedAt = t;
      it.updatedAt = t;
    }
    return all;
  }

  function saveReading(items, opts={}){
    localStorage.setItem(LS_READING, JSON.stringify(items));
    if (!opts.silentBump) bumpLocalUpdatedAt();
  }

  // ----- IndexedDB (PDFs device-local) -----
  function idbOpen(){
    return new Promise((resolve, reject) => {
      const req = indexedDB.open(DB_NAME, DB_VER);
      req.onupgradeneeded = () => {
        const db = req.result;
        if (!db.objectStoreNames.contains(STORE_PDFS)) {
          db.createObjectStore(STORE_PDFS, { keyPath: "id" });
        }
      };
      req.onsuccess = () => resolve(req.result);
      req.onerror = () => reject(req.error);
    });
  }
  async function pdfPut({ id, name, mime, blob }){
    const db = await idbOpen();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(STORE_PDFS, "readwrite");
      tx.objectStore(STORE_PDFS).put({ id, name, mime, blob, savedAt: now() });
      tx.oncomplete = () => resolve(true);
      tx.onerror = () => reject(tx.error);
    });
  }
  async function pdfGet(id){
    const db = await idbOpen();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(STORE_PDFS, "readonly");
      const req = tx.objectStore(STORE_PDFS).get(id);
      req.onsuccess = () => resolve(req.result || null);
      req.onerror = () => reject(req.error);
    });
  }
  async function pdfDelete(id){
    const db = await idbOpen();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(STORE_PDFS, "readwrite");
      tx.objectStore(STORE_PDFS).delete(id);
      tx.oncomplete = () => resolve(true);
      tx.onerror = () => reject(tx.error);
    });
  }

  // ----- Router -----
  const state = { view: "home", editId: null, reviewId: null, readingId: null };

  function setView(view, params={}){
    state.view = view;
    state.editId = params.editId ?? null;
    state.reviewId = params.reviewId ?? null;
    state.readingId = params.readingId ?? null;
    history.replaceState(null, "", hashFor(view, params));
    render();
  }
  function hashFor(view, params={}){
    const p = new URLSearchParams();
    if (params.editId) p.set("id", params.editId);
    if (params.reviewId) p.set("id", params.reviewId);
    if (params.readingId) p.set("id", params.readingId);
    return "#/" + view + (p.toString() ? "?" + p.toString() : "");
  }
  function parseHash(){
    const h = location.hash || "#/home";
    const m = h.match(/^#\/([^?]+)(?:\?(.*))?$/);
    if (!m) return { view: "home", id: null };
    const view = m[1] || "home";
    const qs = new URLSearchParams(m[2] || "");
    return { view, id: qs.get("id") };
  }

  window.addEventListener("hashchange", () => {
    const { view, id } = parseHash();
    if (view === "edit-card") setView("edit-card", { editId: id });
    else if (view === "review") setView("review", { reviewId: id });
    else if (view === "reading-item") setView("reading-item", { readingId: id });
    else setView(["home","review","reading"].includes(view) ? view : "home");
  });

  $$(".tab").forEach(btn => btn.addEventListener("click", () => setView(btn.dataset.nav)));

  // ----- Views -----
  function getStats(cards){
    const todayTs = startOfTodayLocalTs();
    return {
      total: cards.length,
      dueToday: cards.filter(c => isDue(c, todayTs)).length,
      mastered: cards.filter(c => computeStatus(c) === "FUNCTIONAL").length
    };
  }

  function viewHome(cards){
    const { total, dueToday, mastered } = getStats(cards);

    const el = document.createElement("div");
    el.className = "grid";

    const left = document.createElement("div");
    left.className = "card";
    left.innerHTML = `
      <div class="hd"><h2>Home</h2><span class="badge">Sync + Forge</span></div>
      <div class="bd">
        <div class="kpiRow">
          <div class="kpi"><div class="n">${total}</div><div class="l">Total words</div></div>
          <div class="kpi"><div class="n">${dueToday}</div><div class="l">Due today</div></div>
          <div class="kpi"><div class="n">${mastered}</div><div class="l">Functional</div></div>
        </div>

        <div class="hr"></div>

        <div class="field">
          <label>Add words (comma or newline)</label>
          <textarea id="wordInput" placeholder="entropy, laconic\n..."></textarea>
        </div>
        <div class="btnRow">
          <button class="btn full" id="build">Build Deck</button>
        </div>

        <div class="hr"></div>

        <div style="font-weight:900">Sync (GitHub Gist)</div>
        <div class="hint">Keeps phone + computer in sync. Requires internet. Data is stored in your secret Gist.</div>
        <div class="field" style="margin-top:10px">
          <label>Gist ID</label>
          <input id="gistId" type="text" placeholder="gist id" />
        </div>
        <div class="field">
          <label>GitHub Token (Gists: read/write)</label>
          <input id="ghToken" type="password" placeholder="github token" autocomplete="off" autocapitalize="off" spellcheck="false" />
          <div class="hint" id="ghStatus"></div>
        </div>
        <div class="btnRow">
          <button class="btn secondary" id="saveSync">Save</button>
          <button class="btn secondary" id="clearSync">Clear</button>
          <button class="btn secondary" id="revealSync">Reveal</button>
          <button class="btn secondary" id="syncNow">Sync now</button>
        </div>

        <div class="hr"></div>

        <div style="font-weight:900">AI (online)</div>
        <div class="hint">Key is stored only on this device. Reveal shows it temporarily.</div>
        <div class="field" style="margin-top:10px">
          <label>OpenAI API Key</label>
          <input id="apiKey" type="password" placeholder="sk-..." autocomplete="off" autocapitalize="off" spellcheck="false" />
          <div class="hint" id="keyStatus"></div>
        </div>
        <div class="btnRow">
          <button class="btn secondary" id="saveKey">Save</button>
          <button class="btn secondary" id="clearKey">Clear</button>
          <button class="btn secondary" id="revealKey">Reveal</button>
          <button class="btn secondary" id="testKey">Test</button>
        </div>
        <div class="btnRow" style="margin-top:10px">
          <button class="btn full" id="genNew">Generate for NEW cards</button>
        </div>

        <div class="hr"></div>

        <div style="font-weight:900">Backup</div>
        <div class="hint">Export JSON if you want an extra backup. PDFs are device-local.</div>
        <div class="btnRow" style="margin-top:10px">
          <button class="btn secondary" id="exportBtn">Export JSON</button>
          <button class="btn secondary" id="importBtn">Import JSON</button>
          <input type="file" id="importFile" accept="application/json" style="display:none" />
        </div>
      </div>
    `;

    const right = document.createElement("div");
    right.className = "card";
    right.innerHTML = `
      <div class="hd"><h2>Words</h2><span class="badge">Tap to edit</span></div>
      <div class="bd">
        <div class="field">
          <label>Search</label>
          <input id="q" type="text" placeholder="Type to filter…" />
        </div>
        <div class="list" id="list"></div>
      </div>
    `;

    el.appendChild(left);
    el.appendChild(right);

    // Add words
    $("#build", left).onclick = () => {
      const raw = $("#wordInput", left).value || "";
      const parts = raw.split(/[\n,]+/g);
      const words = uniqueWords(parts);
      if (!words.length) return toast("Paste at least one word.");

      const existing = new Set(cards.map(c => (c.word||"").trim().toLowerCase()));
      const newOnes = words.filter(w => !existing.has(w.toLowerCase()));
      if (!newOnes.length) return toast("All of those words already exist.");

      const t = now();
      const toAdd = newOnes.map(w => ({
        id: uid(),
        word: w,
        definition: "",
        examples: "",
        replaces: "",
        mySentence: "",
        mySentenceHistory: [],
        timesReviewed: 0,
        nailedCount: 0,
        box: 1,
        lastReviewedTs: null,
        dateAdded: t,
        updatedAt: t
      }));

      const updated = [...cards, ...toAdd];
      saveCards(updated);
      $("#wordInput", left).value = "";
      toast(`Built ${toAdd.length} cards.`);
      render();
      syncSoon();
    };

    // Sync UI
    const gistIdInput = $("#gistId", left);
    const ghTokenInput = $("#ghToken", left);
    const ghStatus = $("#ghStatus", left);
    const revealSyncBtn = $("#revealSync", left);

    gistIdInput.value = getGistId();

    const savedTok = getGhToken();
    if (ghStatus) ghStatus.textContent = savedTok ? `Token saved (ends with …${savedTok.slice(-4)}).` : "No token saved.";

    let revealedSync = false;
    revealSyncBtn.onclick = () => {
      const k = getGhToken();
      if (!k) return toast("No token saved.");
      revealedSync = !revealedSync;
      ghTokenInput.type = revealedSync ? "text" : "password";
      ghTokenInput.value = revealedSync ? k : "";
      revealSyncBtn.textContent = revealedSync ? "Hide" : "Reveal";
    };

    $("#saveSync", left).onclick = () => {
      setGistId(gistIdInput.value);
      setGhToken(ghTokenInput.value);
      const t2 = getGhToken();
      if (ghStatus) ghStatus.textContent = t2 ? `Token saved (ends with …${t2.slice(-4)}).` : "No token saved.";
      ghTokenInput.type = "password";
      ghTokenInput.value = "";
      revealedSync = false;
      revealSyncBtn.textContent = "Reveal";
      toast(t2 ? "Saved sync." : "Cleared token.");
      syncSoon(true);
    };

    $("#clearSync", left).onclick = () => {
      setGhToken("");
      if (ghStatus) ghStatus.textContent = "No token saved.";
      ghTokenInput.type = "password";
      ghTokenInput.value = "";
      revealedSync = false;
      revealSyncBtn.textContent = "Reveal";
      toast("Cleared.");
      syncSetStatus("no token");
    };

    $("#syncNow", left).onclick = async () => {
      await syncOnce();
      render();
    };

    // Key UI
    const apiKeyInput = $("#apiKey", left);
    const keyStatus = $("#keyStatus", left);
    const saved = getOpenAIKey();
    if (keyStatus) keyStatus.textContent = saved ? `Key saved (ends with …${saved.slice(-4)}).` : "No key saved.";

    let revealed = false;
    $("#revealKey", left).onclick = () => {
      const k = getOpenAIKey();
      if (!k) return toast("No key saved.");
      revealed = !revealed;
      apiKeyInput.type = revealed ? "text" : "password";
      apiKeyInput.value = revealed ? k : "";
      $("#revealKey", left).textContent = revealed ? "Hide" : "Reveal";
    };

    $("#saveKey", left).onclick = () => {
      setOpenAIKey(apiKeyInput.value);
      const saved2 = getOpenAIKey();
      if (keyStatus) keyStatus.textContent = saved2 ? `Key saved (ends with …${saved2.slice(-4)}).` : "No key saved.";
      apiKeyInput.type = "password";
      apiKeyInput.value = "";
      revealed = false;
      $("#revealKey", left).textContent = "Reveal";
      toast(saved2 ? "Saved key." : "Key cleared.");
    };

    $("#clearKey", left).onclick = () => {
      setOpenAIKey("");
      if (keyStatus) keyStatus.textContent = "No key saved.";
      apiKeyInput.type = "password";
      apiKeyInput.value = "";
      revealed = false;
      $("#revealKey", left).textContent = "Reveal";
      toast("Cleared.");
    };

    $("#testKey", left).onclick = async () => {
      try {
        await openaiResponses({ input: [{ role: "user", content: "{\"ok\":true}" }] });
        toast("Key works.");
      } catch (e) {
        if (String(e.message||e) === "NO_KEY") toast("Paste your API key first.");
        else toast("Key test failed.");
        console.warn(e);
      }
    };

    $("#genNew", left).onclick = async () => {
      try {
        if (!getOpenAIKey()) return toast("Paste your API key first.");
        const all = loadCards();
        const targets = all.filter(c => computeStatus(c) === "NEW");
        if (!targets.length) return toast("No NEW cards.");

        let done = 0;
        for (const c of targets) {
          toast(`Generating: ${c.word} (${done+1}/${targets.length})`);
          const fields = await generateCardFields(c.word);
          c.definition = c.definition || fields.definition;
          c.examples = c.examples || fields.examples;
          c.replaces = c.replaces || fields.replaces;
          c.updatedAt = now();
          done++;
          saveCards(all);
        }
        toast(`Generated ${done}.`);
        render();
        syncSoon();
      } catch (e) {
        toast("Generation failed.");
        console.warn(e);
      }
    };

    // Backup import/export
    $("#exportBtn", left).onclick = () => exportJson(cards);
    $("#importBtn", left).onclick = () => $("#importFile", left).click();
    $("#importFile", left).addEventListener("change", async (e) => {
      const f = e.target.files?.[0];
      if (!f) return;
      const txt = await f.text();
      const incoming = safeJsonParse(txt);
      if (!incoming) return toast("Invalid JSON.");
      handleImport(incoming);
      e.target.value = "";
    });

    // Word list
    const list = $("#list", right);
    const q = $("#q", right);
    const draw = () => {
      const f = (q.value || "").trim().toLowerCase();
      const sorted = [...cards].sort((a,b) => (a.word||"").localeCompare(b.word||"", undefined, {sensitivity:"base"}));
      const filtered = f ? sorted.filter(c => (c.word||"").toLowerCase().includes(f)) : sorted;
      list.innerHTML = "";
      if (!filtered.length) {
        list.innerHTML = `<div class="hint">No matches.</div>`;
        return;
      }
      for (const c of filtered) {
        const status = computeStatus(c);
        const div = document.createElement("div");
        div.className = "item";
        div.innerHTML = `
          <div>
            <div class="w">${esc(c.word)}</div>
            <div class="meta">${status} · Box ${c.box} · Reviewed ${c.timesReviewed}×</div>
          </div>
          <div class="badge">Edit</div>
        `;
        div.onclick = () => setView("edit-card", { editId: c.id });
        list.appendChild(div);
      }
    };
    q.addEventListener("input", draw);
    draw();

    return el;
  }

  function viewEditCard(cards, id){
    const card = cards.find(c => c.id === id);
    const el = document.createElement("div");
    el.className = "card";

    if (!card) {
      el.innerHTML = `<div class="hd"><h2>Not found</h2><span class="badge">¯\\_(ツ)_/¯</span></div><div class="bd"><button class="btn full" id="back">Back</button></div>`;
      $("#back", el).onclick = () => setView("home");
      return el;
    }

    el.innerHTML = `
      <div class="hd"><h2>Edit</h2><span class="badge">${computeStatus(card)} · Box ${card.box}</span></div>
      <div class="bd">
        <div style="display:flex;justify-content:space-between;gap:10px;align-items:flex-start">
          <div>
            <div style="font-size:22px;font-weight:950">${esc(card.word)}</div>
            <div class="hint">Generate with AI, then tweak.</div>
          </div>
          <div class="btnRow">
            <button class="btn secondary small" id="genAi">Generate (AI)</button>
            <button class="btn secondary small" id="toReview">Review</button>
          </div>
        </div>

        <div class="hr"></div>

        <div class="field">
          <label>Definition</label>
          <textarea id="def"></textarea>
        </div>
        <div class="field">
          <label>Examples</label>
          <textarea id="ex"></textarea>
        </div>
        <div class="field">
          <label>Replaces</label>
          <input id="rep" type="text" />
        </div>

        <div class="btnRow">
          <button class="btn full" id="save">Save</button>
          <button class="btn secondary full" id="back">Back</button>
        </div>
      </div>
    `;

    $("#def", el).value = card.definition || "";
    $("#ex", el).value = card.examples || "";
    $("#rep", el).value = card.replaces || "";

    $("#back", el).onclick = () => setView("home");
    $("#toReview", el).onclick = () => setView("review", { reviewId: card.id });

    $("#genAi", el).onclick = async () => {
      try {
        if (!getOpenAIKey()) return toast("Add API key on Home first.");
        toast(`Generating: ${card.word}`);
        const fields = await generateCardFields(card.word);
        $("#def", el).value = fields.definition;
        $("#ex", el).value = fields.examples;
        $("#rep", el).value = fields.replaces;
        toast("Generated. Hit Save.");
      } catch (e) {
        toast("Generation failed.");
        console.warn(e);
      }
    };

    $("#save", el).onclick = () => {
      card.definition = $("#def", el).value || "";
      card.examples = $("#ex", el).value || "";
      card.replaces = $("#rep", el).value || "";
      card.updatedAt = now();
      saveCards(cards);
      toast("Saved.");
      setView("home");
      syncSoon();
    };

    return el;
  }

  function viewReview(cards, maybeId){
    const el = document.createElement("div");
    el.className = "reviewShell";

    const todayTs = startOfTodayLocalTs();
    const due = cards.filter(c => isDue(c, todayTs));

    let card = null;
    if (maybeId) card = cards.find(c => c.id === maybeId) || null;
    if (!card) {
      const sorted = [...due].sort((a,b) => (a.box||1) - (b.box||1));
      card = sorted[0] || null;
    }

    const top = document.createElement("div");
    top.className = "card";
    top.innerHTML = `<div class="hd"><h2>Review</h2><span class="badge">${due.length} due</span></div><div class="bd"><div class="hint">Write a sentence. Rate it. (AI grade optional)</div></div>`;
    el.appendChild(top);

    if (!card) {
      const empty = document.createElement("div");
      empty.className = "card reviewCard";
      empty.innerHTML = `<div class="hd"><h2>All caught up</h2><span class="badge">Nice</span></div><div class="bd"><button class="btn full" id="home">Back to Home</button></div>`;
      $("#home", empty).onclick = () => setView("home");
      el.appendChild(empty);
      return el;
    }

    const reviewCard = document.createElement("div");
    reviewCard.className = "card reviewCard";
    reviewCard.innerHTML = `<div class="hd"><h2>Card</h2><span class="badge">${computeStatus(card)} · Box ${card.box}</span></div><div class="bd" id="rb"></div>`;
    el.appendChild(reviewCard);

    function renderFront(){
      const b = $("#rb", reviewCard);
      b.innerHTML = `
        <div class="bigWord">${esc(card.word)}</div>
        <div class="blockTitle">Meaning</div>
        <div class="para">${esc(card.definition || "(empty)")}</div>
        <div class="blockTitle">Examples</div>
        <div class="para">${esc(card.examples || "(empty)")}</div>
        <div class="blockTitle">Replaces</div>
        <div class="para">${esc(card.replaces || "(empty)")}</div>
        <div class="hr"></div>
        <button class="btn full" id="flip">NOW USE IT</button>
      `;
      $("#flip", b).onclick = renderBack;
    }

    function renderBack(){
      const b = $("#rb", reviewCard);
      const hist = normalizeSentenceHistory(card.mySentenceHistory);
      const lastFew = hist.slice().reverse().slice(0, 6);

      b.innerHTML = `
        <div class="bigWord">${esc(card.word)}</div>
        <div class="hint">Type your sentence. Rate it. AI grade uses internet.</div>
        <div class="field" style="margin-top:12px">
          <label>My sentence</label>
          <textarea id="mysent"></textarea>
        </div>
        <div class="btnRow">
          <button class="btn secondary full" id="grade">Grade (AI)</button>
        </div>
        <div class="btnRow">
          <button class="btn good full" id="good">Nailed it</button>
          <button class="btn meh full" id="meh">Meh</button>
          <button class="btn bad full" id="bad">Didn’t know it</button>
        </div>
        <div class="hr"></div>
        <div class="blockTitle">Previous</div>
        <div class="list" id="hist"></div>
      `;

      $("#mysent", b).value = card.mySentence || "";

      const histEl = $("#hist", b);
      for (const e of lastFew) {
        const div = document.createElement("div");
        div.className = "item";
        const grade = (e.grade === null || e.grade === undefined || Number.isNaN(e.grade)) ? "" : ` · ${e.grade}/10`;
        const fb = e.feedback ? `\n${e.feedback}` : "";
        div.innerHTML = `<div><div class="w">${esc(e.t)}</div><div class="meta">${new Date(e.at || now()).toLocaleString()}${grade}${esc(fb)}</div></div><div class="badge">Saved</div>`;
        histEl.appendChild(div);
      }

      $("#grade", b).onclick = async () => {
        const sentence = ($("#mysent", b).value || "").trim();
        if (!sentence) return toast("Type a sentence first.");
        if (!getOpenAIKey()) return toast("Add API key on Home.");

        card.mySentence = sentence;
        card.mySentenceHistory = normalizeSentenceHistory(card.mySentenceHistory);
        card.mySentenceHistory.push({ t: sentence, at: now(), grade: null, feedback: "" });
        card.updatedAt = now();
        saveCards(cards);

        try {
          toast("Grading…");
          const g = await gradeSentenceAI({ word: card.word, definition: card.definition, examples: card.examples, sentence });
          const hist2 = normalizeSentenceHistory(card.mySentenceHistory);
          const last = hist2[hist2.length - 1];
          last.grade = Number.isFinite(g.grade) ? g.grade : null;
          last.feedback = g.feedback || "";
          card.mySentenceHistory = hist2;
          card.updatedAt = now();
          saveCards(cards);
          toast(`Grade: ${g.grade}/10`);
          renderBack();
          syncSoon();
        } catch(e) {
          toast("Grade failed.");
          console.warn(e);
        }
      };

      const rate = (kind) => {
        const sentence = ($("#mysent", b).value || "").trim();
        if (sentence) {
          card.mySentence = sentence;
          card.mySentenceHistory = normalizeSentenceHistory(card.mySentenceHistory);
          card.mySentenceHistory.push({ t: sentence, at: now(), grade: null, feedback: "" });
        } else {
          card.mySentence = "";
        }

        card.timesReviewed = (card.timesReviewed || 0) + 1;
        card.lastReviewedTs = now();

        if (kind === "good") {
          card.box = clamp((card.box || 1) + 1, 1, 3);
          card.nailedCount = (card.nailedCount || 0) + 1;
        } else if (kind === "bad") {
          card.box = 1;
        }

        card.updatedAt = now();
        saveCards(cards);
        setTimeout(() => setView("review"), 150);
        syncSoon();
      };

      $("#good", b).onclick = () => { toast("Nailed it."); rate("good"); };
      $("#meh", b).onclick = () => { toast("Meh."); rate("meh"); };
      $("#bad", b).onclick = () => { toast("Reset."); rate("bad"); };
    }

    renderFront();
    return el;
  }

  function getReadingFeedback(){
    return (localStorage.getItem(LS_READING_FEEDBACK) || "").trim();
  }
  function setReadingFeedback(text){
    localStorage.setItem(LS_READING_FEEDBACK, (text || "").trim());
  }

  function viewReading(items){
    const el = document.createElement("div");
    el.className = "readingSheet";

    const filterVal = { current: "ALL" };
    function getFiltered(){
      const all = loadReading().filter(x => !isDeleted(x));
      const f = filterVal.current;
      return f === "ALL" ? all : all.filter(x => x.type === f);
    }

    el.innerHTML = `
      <div class="sheetToolbar">
        <h2>Reading</h2>
        <span class="badge">Sync list</span>
        <div class="spacer"></div>
        <label style="display:flex;align-items:center;gap:6px;font-size:12px;color:var(--muted);">
          Filter
          <select id="sheetFilter">
            <option value="ALL">All</option>
            <option value="article">Articles</option>
            <option value="book">Books</option>
          </select>
        </label>
        <button class="btn small" id="sheetUploadToggle">Upload list</button>
        <button class="btn small secondary" id="sheetClearAll">Clear all</button>
      </div>
      <div class="sheetScroll">
        <table class="sheetTable">
          <thead>
            <tr>
              <th class="colAuthor">Author</th>
              <th class="colTitle">Book / Title</th>
              <th class="colDesc">Description</th>
              <th class="colStatus">Status</th>
              <th class="colActions"></th>
            </tr>
          </thead>
          <tbody id="sheetBody"></tbody>
          <tbody id="sheetNewRowWrap">
            <tr class="sheetNewRow" id="sheetNewRow">
              <td class="colAuthor"><input type="text" class="cellInput" id="newAuthor" placeholder="Author" /></td>
              <td class="colTitle"><input type="text" class="cellInput" id="newTitle" placeholder="Book or title" /></td>
              <td class="colDesc"><textarea class="cellInput" id="newDesc" placeholder="Description / notes" rows="1"></textarea></td>
              <td class="colStatus"></td>
              <td class="colActions"><button class="btn small" id="sheetAddRow">Add row</button></td>
            </tr>
          </tbody>
        </table>
      </div>
      <div id="sheetUploadArea" style="display:none; padding:12px 14px; border-top:1px solid rgba(34,38,54,.75); background:rgba(11,12,16,.5);">
        <div class="field">
          <label>Paste or upload book list (Author — Title — Description, one per line)</label>
          <textarea id="uploadBookList" placeholder="Paste here or upload .txt below" rows="3"></textarea>
          <input id="uploadBookFile" type="file" accept=".txt,text/plain" style="margin-top:6px" />
          <div class="btnRow" style="margin-top:8px">
            <button class="btn full" id="addBookList">Add these books</button>
          </div>
        </div>
      </div>
      <div class="readingFeedback">
        <details id="feedbackDetails">
          <summary>Feedback on this list</summary>
          <div class="feedbackBody">
            <textarea id="readingFeedbackText" placeholder="Notes, goals, or thoughts about your reading list…"></textarea>
            <button class="btn small" id="saveReadingFeedback">Save feedback</button>
          </div>
        </details>
      </div>
    `;

    const sheetBody = $("#sheetBody", el);
    const sheetFilter = $("#sheetFilter", el);
    const sheetUploadToggle = $("#sheetUploadToggle", el);
    const sheetUploadArea = $("#sheetUploadArea", el);
    const newAuthor = $("#newAuthor", el);
    const newTitle = $("#newTitle", el);
    const newDesc = $("#newDesc", el);
    const sheetAddRow = $("#sheetAddRow", el);
    const uploadBookList = $("#uploadBookList", el);
    const uploadBookFile = $("#uploadBookFile", el);
    const addBookList = $("#addBookList", el);
    const readingFeedbackText = $("#readingFeedbackText", el);
    const saveReadingFeedback = $("#saveReadingFeedback", el);

    readingFeedbackText.value = getReadingFeedback();
    if (getReadingFeedback()) $("#feedbackDetails", el).setAttribute("open", "");

    function drawRows(){
      const show = getFiltered();
      sheetBody.innerHTML = "";
      for (const it of show) {
        const tr = document.createElement("tr");
        const statusClass = (it.status || "TO_READ").replace(/\s/g, "_");
        tr.innerHTML = `
          <td class="colAuthor">${esc(it.author || "")}</td>
          <td class="colTitle">${esc(it.title)}</td>
          <td class="colDesc"><div class="cellDesc">${esc(it.notes || "")}</div></td>
          <td class="colStatus"><span class="statusDot ${esc(statusClass)}"></span>${esc(it.status || "TO_READ")}</td>
          <td class="colActions">
            <button type="button" class="actBtn openBtn" data-id="${esc(it.id)}">Open</button>
            <button type="button" class="actBtn del" data-id="${esc(it.id)}">Delete</button>
          </td>
        `;
        tr.querySelector(".openBtn").onclick = () => setView("reading-item", { readingId: it.id });
        tr.querySelector(".actBtn.del").onclick = async () => {
          if (!confirm("Delete this item?")) return;
          // PDFs are device-local; delete local bytes, but keep a tombstone for sync.
          if (it.pdfId) await pdfDelete(it.pdfId);
          const updated = readingSoftDelete(it.id);
          saveReading(updated);
          toast("Deleted.");
          drawRows();
          syncSoon(true);
        };
        sheetBody.appendChild(tr);
      }
    }

    sheetFilter.value = filterVal.current;
    sheetFilter.onchange = () => { filterVal.current = sheetFilter.value; drawRows(); };
    drawRows();

    sheetUploadToggle.onclick = () => {
      const open = sheetUploadArea.style.display !== "none";
      sheetUploadArea.style.display = open ? "none" : "block";
      sheetUploadToggle.textContent = open ? "Upload list" : "Hide upload";
    };

    $("#sheetClearAll", el).onclick = async () => {
      if (!confirm("Delete all items in the reading list? This cannot be undone.")) return;
      const all = loadReading().filter(x => !isDeleted(x));
      for (const it of all) { if (it.pdfId) await pdfDelete(it.pdfId); }
      // Keep tombstones so the clear propagates to other devices via sync.
      saveReading(readingSoftDeleteAll());
      drawRows();
      syncSoon(true);
      toast("Reading list cleared.");
    };

    function addOneRow(){
      const author = newAuthor.value.trim();
      const title = newTitle.value.trim();
      const desc = newDesc.value.trim();
      if (!title) return toast("Book / title required.");
      const all = loadReading();
      const tNow = now();
      all.unshift({ id: uid(), type: "book", title, author, url: "", status: "TO_READ", notes: desc, pdfId: null, dateAdded: tNow, updatedAt: tNow });
      saveReading(all);
      newAuthor.value = "";
      newTitle.value = "";
      newDesc.value = "";
      newTitle.focus();
      drawRows();
      syncSoon();
      toast("Added.");
    }

    sheetAddRow.onclick = addOneRow;
    newDesc.addEventListener("keydown", (e) => { if (e.key === "Enter" && !e.shiftKey) { e.preventDefault(); addOneRow(); } });
    newTitle.addEventListener("keydown", (e) => { if (e.key === "Enter") { e.preventDefault(); addOneRow(); } });
    newAuthor.addEventListener("keydown", (e) => { if (e.key === "Enter") { e.preventDefault(); newTitle.focus(); } });

    uploadBookFile.addEventListener("change", () => {
      const f = uploadBookFile.files?.[0];
      if (!f) return;
      const r = new FileReader();
      r.onload = () => { uploadBookList.value = (r.result || "").trim(); };
      r.readAsText(f);
    });

    addBookList.onclick = () => {
      const raw = (uploadBookList.value || "").trim();
      if (!raw) return toast("Paste book names or upload a .txt file first.");
      const lines = raw.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
      const all = loadReading();
      const tNow = now();
      const existingKeys = new Set(all.map(x => (x.author + "|" + x.title).toLowerCase()));
      let added = 0;
      for (const line of lines) {
        const parts = line.split(/\s*[—–-]\s*/).map(s => s.trim()).filter(Boolean);
        if (parts.length < 2) continue;
        const author = parts[0];
        const title = parts[1];
        const notes = parts.length >= 3 ? parts.slice(2).join(" — ").trim() : "";
        const key = (author + "|" + title).toLowerCase();
        if (!title || existingKeys.has(key)) continue;
        existingKeys.add(key);
        all.unshift({ id: uid(), type: "book", title, author, url: "", status: "TO_READ", notes, pdfId: null, dateAdded: tNow, updatedAt: tNow });
        added++;
      }
      if (!added) return toast("No new books (duplicates or unparseable lines skipped).");
      saveReading(all);
      uploadBookList.value = "";
      uploadBookFile.value = "";
      toast(`Added ${added} book${added !== 1 ? "s" : ""}.`);
      drawRows();
      syncSoon();
    };

    saveReadingFeedback.onclick = () => {
      setReadingFeedback(readingFeedbackText.value);
      toast("Feedback saved.");
    };

    return el;
  }

  function viewReadingItem(items, id){
    const item = items.find(x => x.id === id);
    const el = document.createElement("div");
    el.className = "card";

    if (!item || isDeleted(item)) {
      el.innerHTML = `<div class="hd"><h2>Not found</h2><span class="badge">¯\\_(ツ)_/¯</span></div><div class="bd"><button class="btn full" id="back">Back</button></div>`;
      $("#back", el).onclick = () => setView("reading");
      return el;
    }

    el.innerHTML = `
      <div class="hd"><h2>${esc(item.type === "article" ? "Article" : "Book")}</h2><span class="badge">${esc(item.status)}</span></div>
      <div class="bd">
        <div style="font-size:22px;font-weight:950">${esc(item.title)}</div>
        <div class="hint">${item.type === "article" ? esc(item.url) : esc(item.author || "")}</div>

        <div class="hr"></div>

        <div class="btnRow">
          <button class="btn secondary" id="back">Back</button>
          <button class="btn secondary" id="open">Open</button>
          <button class="btn secondary" id="del">Delete</button>
        </div>

        <div class="hr"></div>

        <div class="field">
          <label>Notes</label>
          <textarea id="notes"></textarea>
        </div>
        <div class="btnRow">
          <button class="btn full" id="saveNotes">Save notes</button>
        </div>

        <div class="hr"></div>

        <div class="viewer" id="viewer" style="display:none">
          <iframe id="frame" title="reader"></iframe>
        </div>
      </div>
    `;

    $("#notes", el).value = item.notes || "";

    $("#back", el).onclick = () => setView("reading");

    $("#saveNotes", el).onclick = () => {
      item.notes = $("#notes", el).value || "";
      item.updatedAt = now();
      saveReading(items);
      toast("Saved.");
      syncSoon();
    };

    $("#del", el).onclick = async () => {
      if (!confirm("Delete this reading item?")) return;
      if (item.pdfId) await pdfDelete(item.pdfId);
      saveReading(readingSoftDelete(item.id));
      toast("Deleted.");
      setView("reading");
      syncSoon(true);
    };

    $("#open", el).onclick = async () => {
      const viewer = $("#viewer", el);
      const frame = $("#frame", el);

      if (item.type === "article") {
        window.open(item.url, "_blank", "noopener,noreferrer");
        return;
      }

      if (!item.pdfId) return toast("No PDF attached.");
      const rec = await pdfGet(item.pdfId);
      if (!rec?.blob) return toast("PDF missing from storage.");
      const url = URL.createObjectURL(rec.blob);
      viewer.style.display = "block";
      frame.src = url; // browser PDF viewer typically includes search
    };

    return el;
  }

  // ----- Backup -----
  function exportJson(cards){
    const payload = {
      app: "VocabForge",
      exportedAt: new Date().toISOString(),
      version: 3,
      cards,
      reading: loadReading()
    };
    const blob = new Blob([JSON.stringify(payload, null, 2)], {type:"application/json"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `vocabforge-backup-${new Date().toISOString().slice(0,10)}.json`;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
    toast("Exported JSON.");
  }

  function handleImport(incoming){
    let payload = incoming;
    if (Array.isArray(incoming)) payload = { cards: incoming };

    const cards = payload?.cards;
    if (!Array.isArray(cards)) return toast("Import missing cards array.");

    const tNow = now();
    const normalized = cards.map(c => ({
      id: c.id || uid(),
      word: normalizeWord(c.word || ""),
      definition: c.definition ?? "",
      examples: c.examples ?? "",
      replaces: c.replaces ?? "",
      mySentence: c.mySentence ?? "",
      mySentenceHistory: normalizeSentenceHistory(c.mySentenceHistory),
      timesReviewed: Number.isFinite(c.timesReviewed) ? c.timesReviewed : 0,
      nailedCount: Number.isFinite(c.nailedCount) ? c.nailedCount : 0,
      box: clamp((c.box ?? 1), 1, 3),
      lastReviewedTs: Number.isFinite(c.lastReviewedTs) ? c.lastReviewedTs : null,
      dateAdded: Number.isFinite(c.dateAdded) ? c.dateAdded : tNow,
      updatedAt: Number.isFinite(c.updatedAt) ? c.updatedAt : tNow
    })).filter(c => c.word);

    saveCards(normalized);

    if (Array.isArray(payload.reading)) saveReading(payload.reading);

    toast("Imported.");
    render();
    syncSoon(true);
  }

  // ----- Service Worker -----
  async function initServiceWorker(){
    if (!("serviceWorker" in navigator)) {
      $("#swText").textContent = "Offline cache: not supported";
      return;
    }
    try {
      await navigator.serviceWorker.register("./sw.js");
      await navigator.serviceWorker.ready;
      $("#swText").textContent = "Offline cache: ready";
    } catch(e) {
      $("#swText").textContent = "Offline cache: failed";
      console.warn(e);
    }
  }

  function esc(s){
    return String(s ?? "")
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }

  function render(){
    $$(".tab").forEach(b => b.classList.toggle("active", b.dataset.nav === state.view));
    const root = $("#viewRoot");
    root.innerHTML = "";

    const cards = loadCards();
    const reading = loadReading();

    if (state.view === "home") root.appendChild(viewHome(cards));
    else if (state.view === "edit-card") root.appendChild(viewEditCard(cards, state.editId));
    else if (state.view === "review") root.appendChild(viewReview(cards, state.reviewId));
    else if (state.view === "reading") root.appendChild(viewReading(reading));
    else if (state.view === "reading-item") root.appendChild(viewReadingItem(reading, state.readingId));
    else root.appendChild(viewHome(cards));
  }

  // ----- Auto sync orchestration -----
  let syncTimer = null;
  let syncInFlight = false;

  async function syncSoon(immediate=false){
    if (syncInFlight) return;
    if (!getGhToken()) return;
    if (!navigator.onLine) return;

    if (immediate) {
      syncInFlight = true;
      await syncOnce().finally(() => { syncInFlight = false; });
      return;
    }

    if (syncTimer) return;
    syncTimer = setTimeout(async () => {
      syncTimer = null;
      syncInFlight = true;
      await syncOnce().finally(() => { syncInFlight = false; });
    }, 1200);
  }

  function initSyncLoop(){
    // Auto sync on open, then every ~60s
    syncSoon(true);
    setInterval(() => syncSoon(false), 60000);

    window.addEventListener("online", () => syncSoon(true));
    document.addEventListener("visibilitychange", () => {
      if (document.visibilityState === "visible") syncSoon(true);
    });
  }

  function init(){
    // Ensure meta exists
    const metaRaw = localStorage.getItem(LS_META);
    if (!metaRaw) localStorage.setItem(LS_META, JSON.stringify({ createdAt: now(), updatedAt: 0 }));

    // Initial routing
    const { view, id } = parseHash();
    if (view === "edit-card") setView("edit-card", { editId: id });
    else if (view === "review") setView("review", { reviewId: id });
    else if (view === "reading-item") setView("reading-item", { readingId: id });
    else setView(["home","review","reading"].includes(view) ? view : "home");

    initServiceWorker();
    render();

    // Set initial sync status
    syncSetStatus(getGhToken() ? (navigator.onLine ? "ok" : "offline") : "no token");

    initSyncLoop();
  }

  init();
})();
</script>
</body>
</html>
